Exercise - 1 (Basics)
a) Write a JAVA program to display default value of all primitive data type of JAVA

public class InitialValues {
boolean t;
char c;
byte b;
short s;
int i;
long l;
float f;
double d;
void printInitialValues() {
System.out.println("Data type Initial value");
System.out.println("boolean " + t);
System.out.println("char [" + c + "]");
System.out.println("byte " + b);
System.out.println("short " + s);
System.out.println("int " + i);
System.out.println("long " + l);
System.out.println("float " + f);
System.out.println("double " + d);
}
public static void main(String[] args) {
InitialValues iv = new InitialValues();
iv.printInitialValues();
}
}
b) Write a java program that display the roots of a quadratic equation ax2+bx=0. Calculate the discriminate D and basing on value of D, describe the nature of root.

class RootsDemo
{
double a,b,c;
// constructor
RootsDemo(double x, double y, double z)
{
a = x;
b = y;
c = z;
}
void displayRoots()
{
double d = b*b - 4*a*c;
if(d == 0)
{
System.out.println("Roots are real and equal");
double r1,r2;
r1 = r2 = -b/(2*a);
System.out.println("Root1 = " + r1);
System.out.println("Root2 = " + r2);
}else if(d > 0) {
System.out.println("Roots are real and different");
double r1,r2;
r1 = (-b + Math.sqrt(d))/(2*a);
r2 = (-b - Math.sqrt(d))/(2*a);
System.out.println("Root1 = " + r1);
System.out.println("Root2 = " + r2);
}else {
System.out.println("Roots are imaginary");
double rp, ip;
rp = -b/(2*a);
ip = (Math.sqrt(-d))/(2*a);
System.out.println("Root1 : " + rp + " + " + ip + " I ");
System.out.println("Root2 : " + rp + " - " + ip + " I ");
}
}
public static void main(String args[])
{
RootsDemo r1 = new RootsDemo(2,7,3);
r1.displayRoots();
RootsDemo r2 = new RootsDemo(1,2,1);
r2.displayRoots();
RootsDemo r3 = new RootsDemo(6,3,5);
r3.displayRoots();
}
}
c) Five Bikers Compete in a race such that they drive at a constant speed which may or may not be the same as the other. To qualify the race, the speed of a racer must be more than the average speed of all 5 racers. Take as input the speed of each racer and print back the speed of qualifying racers.

import java.util.Scanner;
class Racer
{
String name=null;
double speed = 0;
Racer(String n, double s)
{
name = n;
speed = s;
}
}
class QualifyedRacers
{
public static void main(String[] args)
{
Scanner sc = new Scanner(System.in);
Racer rc[] = new Racer[5];
System.out.println("Enter the details of 5 Racers : ");
for(int i=0; i < 5; i++)
{
System.out.print("Enter Name of " + (i+1) + " Racer : ");
String nm = sc.next();
System.out.print("Enter Speed of " + (i+1) + " Racer : ");
double sp = sc.nextDouble();
rc[i] = new Racer(nm,sp);
}
System.out.println("The details of Racers : ");
System.out.println("sno\tRacer Name \t Speed ");
for(int i=0; i < 5; i++)
{
System.out.println(i + "\t" + rc[i].name + "\t\t" + rc[i].speed);
}
double sum=0.0;
for(int i=0; i < 5; i++)
{
sum = sum + rc[i].speed;
}
double avg = sum/5.0;
System.out.println("Details of qualified Racers : ");
System.out.println("sno\tRacer Name \t Speed ");
for(int i=0; i < 5; i++)
{
if(rc[i].speed > avg)
System.out.println(i + "\t" + rc[i].name + "\t\t" + rc[i].speed);
}
}
}
Exercise - 2 (Operations, Expressions, Control-flow, Strings)
a) Write a JAVA program to search for an element in a given list of elements using binary search
mechanism.

import java.util.Scanner;
public class BinarySearch
{
public static void main(String arg[])
{
Scanner sc = new Scanner(System.in);
int a[] = {2,5,8,14,23,47,88,95};
System.out.println("Enter the element to search");
int key = sc.nextInt();
int index = bsearch(a, key);
if (index != -1) {
System.out.println("Element found at the index : " + index);
} else {
System.out.println("Element not found");
}
}
public static int bsearch(int ar[], int find)
{
int start = 0;
int end = ar.length -1;
int mid;
while (start <= end) {
mid = (start + end) / 2;
if (ar[mid] == find) {
return mid;
} else if (ar[mid] < find) {
start = mid + 1;
} else if (ar[mid] > find) {
end = mid - 1;
}
} // end of while
return -1;
} // end of method
}
b) Write a JAVA program to sort for an element in a given list of elements using bubble sort

import java.util.Scanner;
class BubbleSort
{
public static void main(String args[])
{
Scanner sc = new Scanner(System.in);
System.out.println("How many elements to sort : ");
int size = sc.nextInt();
int arr[] = new int[size];
System.out.println("Enter the elements into the array : ");
for(int i = 0; i < arr.length; i++)
{
System.out.print("Enter arr[" + i + "] : ");
arr[i] = sc.nextInt();
}
System.out.println("given list in the array are : ");
for(int i=0;i<arr.length;i++)
{
System.out.print(" "+arr[i]);
}
// bubble sorting
for(int i=0;i<arr.length;i++)
{
for(int j=i+1;j<arr.length;j++)
{
if(arr[i] > arr[j])
{
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
}
System.out.println("\nThe sorted list is ");
for(int i=0;i<arr.length;i++)
{
System.out.print(" "+arr[i]);
}
}
}
c) Write a JAVA program to sort for an element in a given list of elements using merge sort.

import java.util.Scanner;
public class MergeSort
{
/* Merge Sort function */
public static void sort(int[] a, int low, int high)
{
int n = high - low;
if (n <= 1)
return;
int mid = low + n/2;
// recursively sort
sort(a, low, mid);
sort(a, mid, high);
// merge two sorted subarrays
int[] temp = new int[n];
int i = low, j = mid;
for (int k = 0; k < n; k++)
{
if (i == mid)
temp[k] = a[j++];
else if (j == high)
temp[k] = a[i++];
else if (a[j]<a[i])
temp[k] = a[j++];
else
temp[k] = a[i++];
}
for (int k = 0; k < n; k++)
a[low + k] = temp[k];
}
public static void main(String[] args)
{
Scanner scan = new Scanner( System.in );
System.out.println("Merge Sort Test\n");
int size, i;
/* Accept number of elements */
System.out.println("Enter number of integer elements");
size = scan.nextInt();
/* Create array of n elements */
int arr[] = new int[ size ];
/* Accept elements */
System.out.println("\nEnter "+ size +" integer elements");
for (i = 0; i < arr.length; i++)
arr[i] = scan.nextInt();
/* Call method sort */
sort(arr, 0, size);
/* Print sorted Array */
System.out.println("\nElements after sorting ");
for (i = 0; i < size; i++)
System.out.print(arr[i]+" ");
System.out.println();
}
}
d) Write a JAVA program using StringBuffer to delete, remove character.

public class StringBufferDeleteDemo {
public static void main(String[] args) {
StringBuffer sb1 = new StringBuffer("Hello World");
System.out.println("The string is : " + sb1);
sb1.delete(0,6);
System.out.println("After deleting characters from 0 to 6 ");
System.out.println("The resulted string is : " + sb1);
StringBuffer sb2 = new StringBuffer("Hello good morning");
System.out.println("\nThe string is : " + sb2);
sb2.delete(11, 15);
System.out.println("After deleting substring \"morn\" : ");
System.out.println("The resulted string is : " + sb2);
StringBuffer sb3 = new StringBuffer("Have a nice day");
System.out.println("\nThe string is : " + sb3);
sb3.deleteCharAt(8);
System.out.println("After deleting character at index 8 ");
System.out.println("The resulted string is : " + sb3);
}
}
Exercise - 3 (Class, Objects)
a) Write a JAVA program to implement class mechanism. Create a class, methods and invoke them inside main method.
class Rectangle
{
double length;
double breadth;
}
class RectangleTest
{
public static void main(String[] args)
{
Rectangle r = new Rectangle();
System.out.println("length : " + r.length);
System.out.println("breadth : " + r.breadth);
r.length = 10.0;
r.breadth = 20.0;
double area = r.length * r.breadth;
System.out.println("length : " + r.length);
System.out.println("breadth : " + r.breadth);
System.out.println("Area : " + area);
}
}
Program 2: // a simple class with methods
RectangleTest2.java
class Rectangle
{
double length;
double breadth;
public void area()
{
System.out.println("area"+(length*breadth));
}
}
class RectangleTest2
{
public static void main(String args[])
{
System.out.println("Working with First rectangle : ");
Rectangle r=new Rectangle();
r.length=10.0;
r.breadth=20.0;
System.out.println("length:"+r.length);
System.out.println("breadth:"+r.breadth);
r.area();
System.out.println("\nWorking with Second rectangle : ");
Rectangle p=new Rectangle();
p.length=15.0;
p.breadth=25.0;
System.out.println("length:"+p.length);
System.out.println("breadth:"+p.breadth);
p.area();
}
}
b) Write a JAVA program to implement constructor.

class Rectangle
{
double length;
double breadth;
public Rectangle(double l, double b)
{
length = l; breadth = b;
}
public void area()
{
System.out.println("area : "+(length*breadth));
}
}
class RectangleTest3
{
public static void main(String[] args)
{
System.out.println("creating first rectangle..");
Rectangle r1 = new Rectangle(19,14);
System.out.println("r1.length : " + r1.length);
System.out.println("r1.breadth : " + r1.breadth);
r1.area();
System.out.println("\ncreating second rectangle..");
Rectangle r2 = new Rectangle(35.0, 23.5);
System.out.println("r2.length : " + r2.length);
System.out.println("r2.breadth : " + r2.breadth);
r2.area();
}
}

Exercise - 4 (Methods)
a) Write a JAVA program to implement constructor overloading.

class Box {
double length;
double breadth;
double height;
Box(double l, double b, double h)
{
System.out.println("creating cuboid..");
length = l;
breadth = b;
height= h;
}
Box(double s)
{
System.out.println("creating cube..");
length =breadth = height= s;
}
Box()
{
System.out.println("creating unit cube..");
length =breadth = height= 1.0;
}
public double volume() {
return length * breadth * height;
}
}
class ConstOverloadDemo
{
public static void main(String[] args)
{
Box mybox = new Box(10.0,20.0,15.0);
Box unitcube = new Box();
Box mycube = new Box(10.0);
double vol;
vol = mybox.volume();
System.out.println("\nVolume of mybox : " + vol);
vol = unitcube.volume();
System.out.println("Volume of unitcube : " + vol);
vol = mycube.volume();
System.out.println("Volume of mycube : " + vol);
}
}
b) Write a JAVA program implement method overloading.

class ComplexNumber
{
double rpart;
double ipart;
ComplexNumber(double r, double i)
{
rpart = r; ipart = i;
}
}
class MethodOverLoad
{
public void add(int a, int b)
{
System.out.println("int + int : " + (a + b));
}
public void add(double a, double b, double c)
{
System.out.println("double + double + double : " + (a + b + c));
}
public void add(ComplexNumber c1, ComplexNumber c2)
{
System.out.printf("Complex + Complex : %.4f %+.4f i\n",(c1.rpart + c2.rpart), (c1.ipart + c2.rpart));
}
}
class MethodOverLoadTest
{
public static void main(String args[])
{
MethodOverLoad ob = new MethodOverLoad();
ob.add(10,15);
ob.add(10.0, 15.0, 20.0);
ComplexNumber cno1 = new ComplexNumber(12,15);
ComplexNumber cno2 = new ComplexNumber(7,4);
ob.add(cno1,cno2);
}
}

Exercise - 5 (Inheritance)
a) Write a JAVA program to implement Single Inheritance
class A {
int i, j;
void showij() {
System.out.println("i and j : " + i + " " + j);
}
}
class B extends A {
int k;
void showk() {
System.out.println("k: " + k);
}
void sum() {
System.out.println("i + j + k : " + (i + j + k));
}
}
class InheritTest {
public static void main(String[] args) {
A superOb = new A();
B subOb = new B();
superOb.i = 10;
superOb.j = 20;
System.out.println("Contents of superOb: " );
superOb.showij();
System.out.println();
subOb.i = 7;
subOb.j = 8;
subOb.k = 9;
System.out.println("Contents Of subOb : ");
subOb.showij();
subOb.showk();
System.out.println("Sum of i, j, k in subOb : ");
subOb.sum();
}
}
b) Write a JAVA program to implement multi level Inheritance

class Rectangle {
int length;
int width;
Rectangle() { }
public Rectangle(int l, int w) {
length = l;
width = w;
}
}
class Box extends Rectangle {
int height;
Box() { }
public Box (int l, int w, int h) {
length = l;
width = w;
height = h;
}
public int volume() {
return (length * width * height);
}
}
class SolidBox extends Box {
int density;
public SolidBox(int l, int w, int h, int d) {
length = l;
width = w;
height = h;
density = d;
}
public int weight() {
return(super.volume() * density);
}
}
class MultiLevelInheritTest
{
public static void main(String[] args)
{
Rectangle r1 = new Rectangle(5,8);
System.out.println("Area of rectangle : " + (r1.length * r1.width));
Box b1 = new Box(7,5,9);
System.out.println("Volume of the box : " + b1.volume());
SolidBox m1 = new SolidBox(10,15,25,3);
System.out.println("Volume of the Solid box : " + m1.volume());
System.out.println("The weight of the Solid Box : " + m1.weight() + " KiloGrams.");
}
}
c) Write a java program for abstract class to find areas of different shapes

abstract class Shape {
int dim1;
int dim2;
Shape(int a, int b) {
dim1 = a;
dim2 = b;
}
abstract double area();
}
class ImpRectangle extends Shape{
ImpRectangle(int a, int b) {
super(a,b);
}
public double area() {
return (dim1*dim2);
}
}
class ImpTriangle extends Shape {
ImpTriangle(int a, int b) {
super(a,b);
}
public double area() {
return (dim1*dim2)/2;
}
}
class AbstractTest {
public static void main(String[] args) {
Shape r = new ImpRectangle(20,25);
Shape t = new ImpTriangle(20,25);
System.out.println("Area of Rectangle : " + r.area());
System.out.println("Area of Triangle : " + t.area());
}
}

Exercise - 6 (Inheritance - Continued)
a)	Write a JAVA program give example for “super” keyword.

SuperDemo.java
class Parent
{
int x = 100;
int y;
Parent(int a)
{
y = a;
}
void show()
{
System.out.println("y : " + y);
}
}
class Child extends Parent
{
int x = 110;
int z;
Child(int p, int q)
{
super(p);
z = q;
}
void show()
{
System.out.println("z : " + z);
}
void superX()
{
System.out.println("super.x : " + super.x);
}
void superShow()
{
super.show();
}
}
class SuperDemo
{
public static void main(String args[])
{
Child c1 = new Child(200,220);
c1.show();
c1.superShow();
c1.superX();
System.out.println("child.x : " + c1.x);
}
}
b) Write a JAVA program to implement Interface. What kind of Inheritance can be achieved?
interface Shape { 
double PI = 3.1415; 
void area(); 
void volume(); 
} 
interface Units 
{ 
String AREA_UNITS = " sq. cm."; 
String VOLUME_UNITS = " c. c."; 
} 
class Sphere implements Shape, Units 
{ 
double radius; 
Sphere(double r) 
{ 
radius = r; 
} 
public void area() 
{ 
System.out.println("Surface Area of Sphere : " + 
(4* PI * radius * radius) + AREA_UNITS); 
} 
public void volume() 
{ 
System.out.println("Volume of Sphere : " + 
((4.0/3)* PI * Math.pow(radius,3)) + VOLUME_UNITS); 
} 
} 
class Cube implements Shape, Units 
{ 
double side; 
Cube(double s) 
{ 
side = s; 
} 
public void area() 
{ 
System.out.println("Surface Area of Cube : " + (6 * side * side) + AREA_UNITS); 
} 
public void volume() 
{ 
System.out.println("Volume of Cube : " + 
Math.pow(side,3) + VOLUME_UNITS); 
} 
} 
class InterfaceTest 
{ 
public static void main(String args[]) 
{ 
Shape s[] = { new Sphere(12.5), new Cube(9.7) }; 
for(Shape obj : s) 
{ 
obj.area(); 
obj.volume(); 
} 
} 
}


Exercise - 7 (Exception)
a).Write a JAVA program that describes exception handling mechanism.
Program 1: (Without Try - Catch Block )
ExceptionDemo1.java
import java.util.Scanner;
class ExceptionDemo1
{
public static void main(String[] args)
{
Scanner sc = new Scanner(System.in);
System.out.print("Enter first number : ");
int n1 = sc.nextInt();
 System.out.print("Enter second number : ");
int n2 = sc.nextInt();
int n3 = n1 / n2;
System.out.println(" n1 / n2 = " + n3);
}
}

/////////////////////////////////


ExceptionDemo2 .java
import java.util.Scanner;
class ExceptionDemo2
{
public static void main(String[] args)
{
 try
 {
Scanner sc = new Scanner(System.in);
System.out.print("Enter first number : ");
int n1 = sc.nextInt();
 System.out.print("Enter second number : ");
int n2 = sc.nextInt();
int n3 = n1 / n2;
System.out.println(" n1 / n2 = " + n3);
 } catch (ArithmeticException ae)
 {
 System.out.println("n1 / n2 = " + Double.POSITIVE_INFINITY);
 }
}
}

/////////////////////////////////////////

b).Write a JAVA program Illustrating Multiple catch clauses.
ExceptionDemo3 .java
import java.util.Scanner;
import java.util.InputMismatchException;
class ExceptionDemo3
{
public static void main(String[] args)
{
 try
 {
Scanner sc = new Scanner(System.in);
System.out.print("Enter first number : ");
int n1 = sc.nextInt();
 System.out.print("Enter second number : ");
int n2 = sc.nextInt();
int n3 = n1 / n2;
System.out.println(" n1 / n2 = " + n3);
 } catch (ArithmeticException ae)
 {
 System.out.println("n1 / n2 = " + Double.POSITIVE_INFINITY);
 }
 catch (InputMismatchException ie)
 {
 System.out.println("You should enter integer only." );
 }
}
}

//////////////////////////////////

Exercise – 8 (Runtime Polymorphism)
a). Write a JAVA program that implements Runtime polymorphism
OverridingDemo.java
class Animal {
 void show() {
 System.out.println("I am a generic Animal.");
 }
}
class Dog extends Animal {
 void show() {
 System.out.println("I am a Dog.");
 }
}
class Cow extends Animal {
 void show() {
 System.out.println("I am a Cow.");
 }
}
class Snake extends Animal {
 void show() {
 System.out.println("I am a Snake.");
 }
}
class OverridingDemo
{
 public static void main(String[] args) {
 Animal ref1;
 ref1 = new Animal();
 ref1.show();
 ref1 = new Dog();
 ref1.show();
 ref1 = new Cow();
 ref1.show();
 ref1 = new Snake();
 ref1.show();
 }
}

/////////////////////
b). Write a Case study on run time polymorphism, inheritance that implements in above problem.
Polymorphism is the capability of an action or method to do different things based on the object
that it is acting upon. In other words, polymorphism allows you define one interface and have multiple
implementations. This is one of the basic principles of object oriented programming.
Polymorphism in Java has two types: Compile time polymorphism (static binding) and Runtime
polymorphism (dynamic binding). Method overloading is an example of static polymorphism, while
method overriding is an example of dynamic polymorphism. You can have a method in subclass
overrides the method in its super classes with the same name and signature. Java virtual machine
determines the proper method to call at the runtime, not at the compile time.
Now we are going to study the above example:
 Animal ref1; // a reference variable of super class type ‘Animal’

 ref1 = new Animal();
 ---- reference ‘ref1’ is now referencing to the object of Animal class.
 ref1.show(); // prints the output : I am a generic Animal. ( implementation from Animal class.)
 In java, all non static and non final methods in a class are virtual methods. So they exhibits dynamic
polymorphism. When JVM going to execute the overridden methods, the method implementation is
selected based on type of the object referred , but not the type of reference variable.
 ref1 = new Dog();
 ---- reference ‘ref1’ is now referencing to the object of Dog class, which is sub class to the Animal
class. ( also known as upcasting )
 ref1.show(); // prints the output : I am a Dog . ( implementation from Dog class.)
 ref1 = new Cow();
 ---- reference ‘ref1’ is now referencing to the object of Cow class, which is sub class to the
Animal class.
 ref1.show(); // prints the output : I am a Cow . ( implementation from Cow class.)
 ref1 = new Snake();
 ---- reference ‘ref1’ is now referencing to the object of Snake class, which is sub class to the
Animal class.
 ref1.show(); // prints the output : I am a Snake . ( implementation from Snake class.)
Rules for method overriding:
• In java, a method can only be overridden in Subclass, not in same class.
• The argument list should be exactly the same as that of the overridden method.
• The return type should be the same or a subtype of the return type declared in the original
overridden method in the super class.
• The access level cannot be more restrictive than the overridden method’s access level. For
example: if the super class method is declared public then the overridden method in the sub
class cannot be either private or protected.
• Instance methods can be overridden only if they are inherited by the subclass.
• A method declared final cannot be overridden.
• A method declared static cannot be overridden but can be re-declared.
• If a method cannot be inherited then it cannot be overridden.
• A subclass within the same package as the instance’s superclass can override any superclass
method that is not declared private or final.
• A subclass in a different package can only override the non-final methods declared public or
protected.
• An overriding method can throw any uncheck exceptions, regardless of whether the overridden
method throws exceptions or not. However the overriding method should not throw checked
exceptions that are new or broader than the ones declared by the overridden method. The
overriding method can throw narrower or fewer exceptions than the overridden method.
• Constructors cannot be overridden.
/////////////////////////////////
a). Write a JAVA program for creation of Illustrating throw.
ThrowDemo.java
import java.util.Scanner;
class NotEligibleException extends Exception
{
public String toString()
{
 return "You are not eligible for voting..";
}
}
class ThrowDemo
{
public static void main(String[] args)
{
Scanner sc = new Scanner(System.in);
try
{
System.out.print("Enter your age : ");
int age = sc.nextInt();
if(age < 18)
{
throw new NotEligibleException();
} else {
System.out.println("Welcome! You are eligible for voting!");
}
}
catch (NotEligibleException ne)
{
System.out.println(ne);
}
}
}
////////////////////////

b). Write a JAVA program for creation of Illustrating finally.
TransactionTest.java
import java.util.Scanner;
class WrongPinException extends Exception
{
public String toString()
{
return "you entered wrong pin number..";
}
}
class TransactionTest
{
public static void main(String[] args)
{
Scanner sc = new Scanner(System.in);
double balance = 25000.0;
int pin = 1234;
String status = "Transaction failed..";
System.out.println("Your current balance : Rs." + balance);
try
{
System.out.print("Enter the withdraw amount : ");
double amount = sc.nextDouble();
System.out.print("Enter your pin : ");
int num = sc.nextInt();
if(num != pin)
{
throw new WrongPinException();
}
balance = balance - amount;
 status = "Transaction successful..";
}
catch (WrongPinException pe)
{
System.out.println(pe);
}
finally
{
System.out.println("This is finally block...");
System.out.println(status);
System.out.println("Your fresh balance is : " + balance);
System.out.println("your account is closed...");
}
}
}

/////////////////////
c). Write a JAVA program for creation of Java Built-in Exceptions.
BuiltInException.java
class BuiltInException
{
 public Object createException()
 {
Class c = null;
Object obj = null;
try {
 c = Class.forName("java.lang.ArithmeticException");
 } catch (ClassNotFoundException e) {
 e.printStackTrace();
 }
try {
 obj = c.newInstance();
 } catch (InstantiationException e) {
 e.printStackTrace();
 } catch (IllegalAccessException e) {
 e.printStackTrace();
 }
return obj;
 }
 public static void main(String[] args)
 {
 BuiltInException b = new BuiltInException();
 try
 {
 throw (Exception)b.createException();
} catch (Exception e) {
 System.out.println("Object of \"" + e + "\" is instantiated..");
}
 }
}

//////////////////////////////
Exercise – 12 (Packages)
a). Write a JAVA program illustrate class path.
Steps working with packages and CLASSPATH :
1. create a base folder : d:\javalab. In the base folder create a sub folder named myprograms. Now the
complete base directory path is : "d:\javalab\myprograms ".
2. Now create a source program which is defined with package as below :
Circle.java
package com.aditya.demo;
public class Circle
{
 double radius;
public Circle(double r)
{
radius = r;
}
public void area()
{
System.out.println("Area : " + (3.1415*radius*radius));
}
public static void main(String[] args)
{
Circle c1 = new Circle(12.5);
c1.area();
}
}
3. Save the file as Circle.java in the folder "d:\javalab\myprograms ".
4. Now compile the program with the command as below :
 D:\javalab\myprograms\> javac -d . Circle.java
5. Now the generated .class file is stored in the created sub directory path as below :
D:\javalab\myprograms\com\aditya\demo\Circle.class
6. In the above path "d:\javalab\myprograms " is called base directory path, and "com\aditya\demo " is
called package directory path.
7. Now in the Environment variables, set CLASSPATH variable as below:
 CLASSPATH=.; d:\javalab\myprograms ;
 And save the variable. ( now base directory path is included in CLASSPATH variable.
8. Now again open the command window , and execute the java program as below :
D:\javalab\myprograms\> java com.aditya.demo.Circle 
b). Write a case study on including in class path in your os environment of your package. Package A package is a collection of related Java entities (such as classes, interfaces, exceptions, errors and enums). Packages are used for: 1. Resolving naming conflict of classes by prefixing the class name with a package name. For example, com.zzz.Circle and com.yyy.Circle are two distinct classes. Although they share the same class name Circle, but they belong to two different packages: com.zzz and com.yyy. These two classes can be used in the same program and distinguished using the fully-qualified class name - package name plus class name. This mechanism is called Namespace Management. 2. Access Control: Besides public and private, Java has two access control modifiers – protected and default – that are related to package. A protected entity is accessible by classes in the same package and its subclasses. An entity without access control modifier (i.e., default) is accessible by classes in the same package only. 3. For distributing a collection of reusable classes, usually in a format known as Java Archive (JAR) file. Package Naming Convention A package name is made up of the reverse of the Internet Domain Name (to ensure uniqueness) plus your own organization's internal project name, separated by dots '.'. Package names are in lowercase. For example, suppose that your Internet Domain Name is "zzz.com", you can name your package as "com.zzz.project1.subproject2". Package Name & the Directory Structure The package name is closely associated with the directory structure used to store the classes. The classes (and other entities) belonging to a specific package are stored together in the same directory. Furthermore, they are stored in a sub-directory structure specified by its package name. For example, the class Circle of package com.zzz.project1.subproject2 is stored as "$BASE_DIR\com\zzz\project1\subproject2\Circle.class", where $BASE_DIR denotes the base directory of the package. Clearly, the "dot" in the package name corresponds to a sub-directory of the file system. The base directory ($BASE_DIR) could be located anywhere in the file system. Hence, the Java compiler and runtime must be informed about the location of the $BASE_DIR so as to locate the classes. This is accomplished by an environment variable called CLASSPATH. CLASSPATH is similar to another environment variable PATH, which is used by the command shell to search for the executable programs. Steps working with packages and CLASSPATH : 1. create a base folder : d:\javalab. In the base folder create a sub folder named myprograms. Now the complete base directory path is : "d:\javalab\myprograms ". 2. Now create a source program which is defined with package com.aditya.demo. 3. Save the file as Circle.java in the folder "d:\javalab\myprograms ". 4. Now compile the program with the command as below : D:\javalab\myprograms\> javac -d . Circle.java 5. Now the generated .class file is stored in the created sub directory path as below : D:\javalab\myprograms\com\aditya\demo\Circle.class 6. In the above path "d:\javalab\myprograms " is called base directory path, and "com\aditya\demo " is called package directory path. 7. Now in the Environment variables, set CLASSPATH variable as below: CLASSPATH=.; d:\javalab\myprograms ; And save the variable. ( now base directory path is included in CLASSPATH variable. 8. Now again open the command window , and execute the java program as below : D:\javalab\myprograms\> java com.aditya.demo.Circle When programming in Java, you make other classes available to the class you are writing by putting something like this at the top of your source file. The Java Virtual Machine will know where to find your compiled class. It would be impractical to have the VM look through every folder on your machine, so you have to provide the VM a list of places to look. This is done by putting folder and jar files on your classpath. So, classpaths contain:  JAR files, and•  Paths to the top of package hierarchies.• CLASSPATH can be set in one of the following ways: CLASSPATH can be set permanently in the environment: In Windows, choose control panel ⇒ System ⇒ Advanced ⇒ Environment Variables ⇒ choose "System Variables" (for all the users) or "User Variables" (only the currently login user) ⇒ choose "Edit" (if CLASSPATH already exists) or "New" ⇒ Enter "CLASSPATH" as the variable name ⇒ Enter the required directories and JAR files (separated by semicolons) as the value (e.g., ".;c:\javaproject\classes;d:\tomcat\lib\servlet-api.jar"). Take note that you need to include the current working directory (denoted by '.') in the CLASSPATH. To check the current setting of the CLASSPATH, issue the following command: > SET CLASSPATH CLASSPATH can be set temporarily for that particular CMD shell session by issuing the following command: > SET CLASSPATH=.;c:\javaproject\classes;d:\tomcat\lib\servlet-api.jar Instead of using the CLASSPATH environment variable, you can also use the command-line option -classpath or - cp of the javac and java commands, for example, > java –classpath c:\javaproject\classes com.abc.project1.subproject2.MyClass

